use std::cell::RefCell;
use std::collections::{HashSet, LinkedList};
use std::ops::Deref;
use std::rc::Rc;
use std::time::Instant;
use aoctools::{parse, read_whole_file};
use crate::Direction::{BackForSnack, FirstGo, GoWithSnack};
use crate::List::{Cons, Nil};

fn main() {

    let content = read_whole_file("input_test.txt");
    let lines: Vec<&str> = content.split("\n").filter(|s| !s.trim().is_empty()).collect();

    let mut blizzards0: Vec<Blizzard> = Vec::new();
    // let mut visited: Vec<Vec<bool>> = Vec::new();

    let height = lines.len() - 2;
    let max_y = height - 1;
    let mut max_x = 0;
    let mut number_of_blizzards = 0;
    for i in 0..height {
        let chars = lines[i + 1].chars().collect::<Vec<char>>();
        let num_of_chars = chars.len();
        max_x = num_of_chars - 3;
        // visited.push(Vec::new());
        for j in 0..num_of_chars-2 {
            // visited[i - 1].push(false);
            if chars[j + 1] != '.' {
                blizzards0.push(Blizzard::new(j, i, chars[j + 1]));
                number_of_blizzards += 1;
            }
        }
    }
    // let mut solution = (max_x, max_y + 1);

    let mut minute: usize = 0;
    let mut stop = false;
    // let mut blizzards = Rc::new(RefCell::new(blizzards0));
    // let mut blizzards = RefCell::new(Rc::new(blizzards0));

    let blizzards: Rc<RefCell<Vec<Blizzard>>> = Rc::new(RefCell::new(blizzards0));

    // print(Rc::clone(&blizzards), (0, -1), max_x, max_y);

    // let coto = <RefCell<Vec<Blizzard>>>::borrow(&blizzards);
    // let coto2 = coto.len();

    // let coto2 = blizzards.len();

    // println!("number_of_blizzards: {}", number_of_blizzards);
    // println!("number_of_blizzards: {}", coto2);
    // println!("max_x: {}, max_y: {}, solution: {:?}", max_x, max_y, solution);

    // let number_of_blizzards = blizzards.borrow().borrow().len();
    // let mut tasks0: Vec<LinkedList<Task>> = Vec::new();
    let mut tasks: LinkedList<LinkedList<Task>> = LinkedList::new();


    // println!("{:?}", blizzards);


    let now = Instant::now();
    let mut solution_printed = 0;
    // From initial state to Minute 1:
    for i in 0..number_of_blizzards {
        (*blizzards).borrow_mut()[i].mov(max_x, max_y);
    }
    let task = Task {
        expedition: (0, -1),
        blizzards: Rc::clone(&blizzards),
        minute,
        previous: Rc::new(Nil),
    };
    tasks.push_back(LinkedList::from([task]));

    let mut first_move_done = false;
    let mut direction: Direction = FirstGo;
    while !stop && minute < 27 {

        let mut tasks_for_this_minute: LinkedList<Task> = tasks.pop_front().unwrap();
        println!("Minute: {}, number of tasks: {}", minute, tasks_for_this_minute.len());

        let mut not_moved_yet = true; // move blizzards only once per each minute
        let mut tasks_for_next_minute: LinkedList<Task> = LinkedList::new();
        let mut adjacent_for_next_minute: HashSet<(i32, i32)> = HashSet::new();
        while let Some(task) = tasks_for_this_minute.pop_front() {
            if minute >= 18 {
                match task.previous.deref() {
                    Cons((prev_x, prev_y), _) => println!("(minute {}) task: {:?}, prev: ({}, {})", minute, task.expedition, prev_x, prev_y),
                    Nil => (),
                }

            }
            let expedition = task.expedition;

            let solution_found = ((direction == FirstGo || direction == GoWithSnack) && (expedition.0 == max_x as i32 && expedition.1 == max_y as i32 + 1))
                || (direction == BackForSnack && expedition.0 == 0 && expedition.1 == -1);

            if solution_found {
                println!("Solution found direction: {:?} expedition: {:?}", direction, expedition);
                if solution_printed == 0 && direction == FirstGo {
                    let list = Rc::new(Cons(expedition, Rc::clone(&task.previous)));
                    let mut path: LinkedList<(i32, i32)> = LinkedList::new();
                    build_path(Rc::clone(&list), &mut path);
                    print_all(path, Rc::clone(&blizzards), minute, max_x, max_y);
                    solution_printed += 1;
                    println!("Part one: (above) {} expedition: {:?}", minute, expedition);
                    // stop = true;
                    while let Some(r) = tasks_for_this_minute.pop_front() {
                        println!("Removing task for this minute: {:?}", r.expedition);
                    }
                    while let Some(r) = tasks_for_next_minute.pop_front() {
                        println!("Removing tasks for next minute generated by another tasks for this minute: {:?}", r.expedition);
                    }
                }
                if solution_printed == 1 && direction == GoWithSnack {
                    let list = Rc::new(Cons(expedition, Rc::clone(&task.previous)));
                    let mut path: LinkedList<(i32, i32)> = LinkedList::new();
                    build_path(Rc::clone(&list), &mut path);
                    // print_all(path, Rc::clone(&blizzards), minute, max_x, max_y);
                    solution_printed += 1;
                    println!("Part two: (above) {}", minute);
                    stop = true;
                }
                first_move_done = false;
                direction = direction.next();
            }
            if not_moved_yet {
                for i in 0..number_of_blizzards {
                    (*blizzards).borrow_mut()[i].mov(max_x, max_y);
                }
                not_moved_yet = false;
            }


            match direction {
                FirstGo | GoWithSnack =>
                    if !first_move_done && !check_if_blizzard_here(Rc::clone(&blizzards), number_of_blizzards, 0, 0) {
                        first_move_done = true;
                    },
                BackForSnack =>
                    if !first_move_done && !check_if_blizzard_here(Rc::clone(&blizzards), number_of_blizzards, max_x, max_y) {
                        first_move_done = true;
                    },
            };

            let adjacents = vec!((expedition.0, expedition.1 - 1),
                                     (expedition.0 - 1, expedition.1),
                                     (expedition.0, expedition.1),
                                     (expedition.0 + 1, expedition.1),
                                     (expedition.0, expedition.1 + 1));
            if minute == 18 {
                println!("Minute ({}) Adjacents: {:?}, direction: {:?}", minute, adjacents, direction);
            }
            for i in 0..adjacents.len() {
                let x = adjacents[i].0;
                let y = adjacents[i].1;
                let still_wait = !first_move_done && ((x == 0 && y == -1 && (direction == FirstGo || direction == GoWithSnack)) || (x == max_x as i32 && y == max_y as i32 + 1 && (direction == BackForSnack)));
                let normal_move = first_move_done && x >= 0 && x <= max_x as i32 && y >= 0 && y <= max_y as i32;
                let solution_move = first_move_done && x == max_x as i32&& y == max_y as i32 + 1 && (direction == FirstGo || direction == GoWithSnack);
                let back_for_snack = direction == BackForSnack && x == 0 && y == -1;

                println!("Minute ({}) adjacent: {:?} | still_wait: {} | normal_move {} | solution_move {} | back_for_snack {} ", minute, adjacents[i], still_wait, normal_move, solution_move, back_for_snack);


                if still_wait || normal_move || solution_move || back_for_snack {
                    println!("Minute ({}) adjacent: {:?}", minute, adjacents[i]);

                    let blizzard_here = check_if_blizzard_here(Rc::clone(&blizzards), number_of_blizzards, x as usize, y as usize);
                    if !blizzard_here && !adjacent_for_next_minute.contains(&adjacents[i]) {
                        let previous = Rc::new(Cons(expedition, Rc::clone(&task.previous)));
                        let task = Task {
                            expedition: adjacents[i],
                            blizzards: Rc::clone(&blizzards),
                            minute: minute + 1,
                            previous: previous,
                        };
                        tasks_for_next_minute.push_back(task);
                        adjacent_for_next_minute.insert(adjacents[i]);
                        // println!("number of tasks for this minute: {}", tasks_for_this_minute.len());
                        // println!("number of tasks for next minute: {}", tasks_for_next_minute.len());
                    }
                }
            }
        }
        tasks.push_back(tasks_for_next_minute);
        minute += 1;
    }

    let elapsed = now.elapsed();
    println!("elapsed: {:?}", elapsed);

    println!("Part one: {}", minute);

    // Part one: 196 - too low (198 tez za male)

}

#[derive(PartialEq)]
#[derive(Debug)]
enum Direction {
    FirstGo,
    BackForSnack,
    GoWithSnack,
}

impl Direction {
    fn next(&self) -> Direction {
        match self {
            FirstGo => BackForSnack,
            BackForSnack => GoWithSnack,
            GoWithSnack => FirstGo,
        }
    }
}

fn check_if_blizzard_here(blizzards: Rc<RefCell<Vec<Blizzard>>>, number_of_blizzards: usize, check_x: usize, check_y: usize) -> bool {
    let mut blizzard_here = false;
    let mut j = 0;
    while !blizzard_here && j < number_of_blizzards {
        let bs = blizzards.deref().borrow();
        if bs[j].x == check_x && bs[j].y == check_y {
            blizzard_here = true;
        }
        j += 1;
    }
    blizzard_here
}

#[warn(dead_code)]
fn wait() {
    use std::io;
    use std::io::prelude::*;
    let mut stdin = io::stdin();
    let _ = stdin.read(&mut [0u8]).unwrap();
}

fn print_path(list: Rc<List>, minute: i32) {
    match list.deref() {
        Cons((x, y), prev) => {
            println!("minute {}: ({}, {})", minute, x, y);
            print_path(Rc::clone(prev), minute - 1);
        }
        Nil => (),
    }
}

fn build_path(list: Rc<List>, path: &mut LinkedList<(i32, i32)>) {
    match list.deref() {
        Cons((x, y), prev) => {
            let xx = *x;
            let yy = *y;
            path.push_front((xx, yy));
            // println!("minute {}: ({}, {})", minute, x, y);
            build_path(Rc::clone(prev), path);
        }
        Nil => (),
    }
}

fn print_all(path: LinkedList<(i32, i32)>, blizzards: Rc<RefCell<Vec<Blizzard>>>, minutes: usize, max_x: usize, max_y: usize) {
    let mut bs = blizzards.deref().borrow_mut();
    for _ in 0..minutes {
        for i in 0..bs.len() {
            bs[i].mov_back(max_x, max_y);
        }
    }
    let mut bs2 = vec![];
    for i in 0..bs.len() {
        bs2.push(Blizzard::new(bs[i].x, bs[i].y, bs[i].d));
    }
    let rc_bs2 = Rc::new(RefCell::new(bs2));
    let mut m = 1;
    println!("************ PATH ************");
    for p in path {
        println!("\nMinute: {}", m);
        print(Rc::clone(&rc_bs2), p, max_x, max_y);
        m += 1;
    }
    println!();
    println!("************ PATH ************");
}

fn print(blizzards: Rc<RefCell<Vec<Blizzard>>>, expedition: (i32, i32), max_x: usize, max_y: usize) {
    let mut m: Vec<Vec<char>> = vec![];
    for x in 0..max_x + 1 {
        m.push(vec![]);
        for y in 0..max_y + 1 {
            if expedition.0 != x as i32 || expedition.1 != y as i32 {
                m[x].push('.');
            } else {
                m[x].push('E');
            }

        }
    }

    let bs = blizzards.deref().borrow();
    for i in 0..bs.len() {
        let cu = m[bs[i].x][bs[i].y];
        if cu == '.' {
            m[bs[i].x][bs[i].y] = bs[i].d;
        } else if cu == '<' || cu == '>' || cu == '^' || cu == 'v' {
            m[bs[i].x][bs[i].y] = '2';
        } else if cu != 'E' {
            m[bs[i].x][bs[i].y] = (parse(cu.to_string().as_str()) + 1).to_string().chars().next().unwrap();
        }
    }

    if expedition.0 == 0 && expedition.1 == -1 {
        print!("#E#");
    } else {
        print!("#.#");
    }
    for _ in 0..max_x {
        print!("#");
    }
    println!();
    for y in 0..max_y + 1 {
        print!("#");
        for x in 0..max_x + 1 {
            print!("{}", m[x][y]);
        }
        println!("#");
    }
    for _ in 0..max_x + 1 {
        print!("#");
    }
    if expedition.1 > max_y as i32 {
        print!("E");
    } else {
        print!(".");
    }
    print!("#");
    println!()
}

#[derive(Debug)]
enum List {
    Cons((i32, i32), Rc<List>),
    Nil
}

#[derive(Debug)]
struct Task {
    expedition: (i32, i32),
    blizzards: Rc<RefCell<Vec<Blizzard>>>,
    minute: usize,
    previous: Rc<List>,
}

#[derive(Debug)]
struct Blizzard {
    x: usize,
    y: usize,
    d: char,
}

impl Blizzard {
    fn new(x: usize, y: usize, d: char) -> Blizzard {
        // println!("Blizzard ( x: {}, y: {}, d: {} )", x, y, d);
        Blizzard { x, y, d }
    }

    fn mov_back(&mut self, max_x: usize, max_y:usize) {
        if self.d == '>' {
            if self.x > 0 {
                self.x -= 1;
            } else {
                self.x = max_x;
            }
        } else if self.d == '<' {
            if self.x < max_x {
                self.x += 1;
            } else {
                self.x = 0;
            }
        } else if self.d == 'v' {
            if self.y > 0 {
                self.y -= 1;
            } else {
                self.y = max_y;
            }
        } else if self.d == '^' {
            if self.y < max_y {
                self.y += 1;
            } else {
                self.y = 0;
            }
        }
    }

    fn mov(&mut self, max_x: usize, max_y:usize) {
        if self.d == '<' {
            if self.x > 0 {
                self.x -= 1;
            } else {
                self.x = max_x;
            }
        } else if self.d == '>' {
            if self.x < max_x {
                self.x += 1;
            } else {
                self.x = 0;
            }
        } else if self.d == '^' {
            if self.y > 0 {
                self.y -= 1;
            } else {
                self.y = max_y;
            }
        } else if self.d == 'v' {
            if self.y < max_y {
                self.y += 1;
            } else {
                self.y = 0;
            }
        }
    }

}